# Machine-Learning-Based Blind Source Separation

## About this Repository


This code is a modification of the RF Challenge [starter code](https://github.com/RFChallenge/icassp2024rfchallenge)

## RF Challenge Dataset

[Click here for the RF Challenge Interference Dataset](https://www.dropbox.com/scl/fi/zlvgxlhp8het8j8swchgg/dataset.zip?rlkey=4rrm2eyvjgi155ceg8gxb5fc4&dl=0)


## weights
QPSK DTS weights for the UNet can be obtained here: [reference_models.zip](https://www.dropbox.com/scl/fi/890vztq67krephwyr0whb/reference_models.zip?rlkey=6yct3w8rx183f0l3ok2my6rej&dl=0)
(`/models` folder, `/torchmodels` is irrelavant)

8/16PSK DTS weights, along with all 5L-UJM and UJM weights can be obtained here: (insert link).

#### File Descriptions:

For a complete overview of the dependencies within our Anaconda environment, please refer [here (tf_env)](https://github.com/amirweiss15/ICC2026_dts_vs_ujm/blob/main/tf_env.yml). 

note: since the interference mixture notation for K=2 "b1/b2" can be problematic as a file path name, we have decided to denote it in the code as "b1∨b2", where ∨ is the logical "or" operation symbol.

## Files for training:

(1). `generate_training_dataset.py`: python script that creates D sample mixtures with varying random target SINR levels (ranging between -33 dB and 3 dB). For each signal mixture configuration, the output is saved as D/n HDF5 files, each containing n mixtures. For the paper we used the default RF Challenge setup of D=240000 and n=4000, making 60 HDF5 files for each mixture dataset.

(2). `example_tfds_preprocess_mixture_dataset.py`: preprocesses the training dataset created in (1) into a supervised-learning TensorFlow dataset. In the terminal use the command `tfds build dataset_utils/example_tfds_preprocess_mixture_dataset.py --data_dir tfds/` in order to run it.

(3). `train_unet_model.py`: trains the Tensorflow UNet architecture (see `src/unet_model.py` and `unet_8layered_model.py`) on the tfds dataset created in (2).

## Files for testing
(1). `generate_mixture_with_uncertainty_testset.py`: generates a testset of a signal mixture with an interference mixture of P(b1)=p, of 11 discrete target SINR levels. Saves a pickle file `Dataset_Seed[seed]_[soi_type]+[interference_type1]∨[interference_type2].pkl` that contains `all_sig_mixture, all_sig1_groundtruth, all_bits1_groundtruth, meta_data`, sorted by SINR levels.

(2). `generate_mixture_single_interference_testset.py`: same as (1) but for p=1 only, i.e., saves it as `Dataset_Seed[seed_number]_[soi_type]+[interference_sig_type].pkl`.

(3). `evaltest_unet_interference_uncertainty.py`: processes the testset created in (1) on the desired UNet model (DTS, 5L-UJM, UJM), both waveform prediction and BER calculation. Saves results in the `/outputs` folder.

(4). `evaltest_unet_single_interference.py`: same as (3) but for the testset created in (2). Here interfrence type 2 (p=0) is decided by which 5L-UJM/UJM is chosen.

## Utility files
(1). The SOI is generated by the files in the `/rfutils` folder.
   
(2). `plot_figure_save_results.py`: calculates the MSE and BER and saves them in a `.npz` file along with pyplots in the `/outputs` folder. Make sure the n_per_sinr matches the one you generated in the testset!
qpsk2_helper_fn.py
qam16_helper_fn.py
ofdm_helper_fn.py


